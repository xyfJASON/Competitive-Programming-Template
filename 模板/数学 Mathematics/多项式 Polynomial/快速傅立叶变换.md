<h1 style="text-align: center"> 快速傅立叶变换 </h1>

<h2 style="text-align: center"> Fast Fourier Transfrom </h2>



**Idea**：多项式在系数表示下的乘法需要 $O(n^2)$ 的时间，但在点值表示下的乘法仅需 $O(n)$ 的时间，**离散傅立叶变换（DFT）**提供了将多项式从系数表示转换到点值表示的方法，而其逆运算**（IDFT）**将多项式从点值表示转换到系数表示。为了方便，我们常选用**单位复数根**作为这些点。利用单位复数根的性质，**快速傅立叶变换（FFT）**采用**分治**的思路将复杂度降低至 $O(n\lg n)$ ——分别计算奇数项和偶数项，然后合并；而运用可逆矩阵与范德蒙德矩阵等知识，可以推出逆FFT的公式，并发现其与FFT有惊人的相似性。递归实现的FFT效率不是很高，常数大，可将其改为迭代形式，不过自底而上的迭代实现需要知道递归树中叶子节点的顺序——我们发现该顺序正好是**位逆序置换**，可以预处理出来。

**Complexity**：$O(n\lg n)$ 

**ATT**：$n$ 要选取 $2$ 的整数幂。

**Reference**：《算法导论》P527-541. 

**Code**：

```cpp
#include<cmath>
#include<cstdio>
#include<algorithm>

using namespace std;

const int N = 3000005;
const double PI = acos(-1);

struct Complex{
	double real, imag;
	Complex():real(0),imag(0){}
	Complex(double r, double i){ real = r; imag = i; }
	Complex operator + (Complex &A){ return Complex(real+A.real,imag+A.imag); }
	Complex operator - (Complex &A){ return Complex(real-A.real,imag-A.imag); }
	Complex operator * (Complex &A){ return Complex(real*A.real-imag*A.imag,real*A.imag+imag*A.real); }
};

int lenf, leng, rev[N];
Complex f[N], g[N];

void fft(Complex A[], int n, int flag){ // flag == 1: fft; flag == -1: ifft
	for(int i = 0; i < n; i++)
		if(i < rev[i])
			swap(A[i], A[rev[i]]);
	for(int m = 2; m <= n; m <<= 1){
		Complex wm( cos(2*PI/m), flag * sin(2*PI/m) ); // mth unit root
		for(int k = 0; k < n; k += m){
			Complex w(1, 0);
			for(int j = 0; j < m / 2; j++){
				Complex t = w * A[k+j+m/2], u = A[k+j];
				A[k+j] = u + t;
				A[k+j+m/2] = u - t;
				w = w * wm;
			}
		}
	}
	if(flag == -1)
		for(int i = 0; i < n; i++)
			A[i].real /= n;
}

int main(){
	lenf = read(); leng = read();
	for(int i = 0; i <= lenf; i++)
		f[i].real = read();
	for(int i = 0; i <= leng; i++)
		g[i].real = read();
	int n = 1, cntBit = 0;
	while(n <= lenf + leng){
		n <<= 1;
		cntBit++;
	}							// n == 2^cntBit is a upper bound of lenf+leng
	for(int i = 0; i < n; i++)	// rev[k] is bit-reversal permutation of k
		rev[i] = ( rev[i>>1] >> 1 ) | ( (i&1) << (cntBit-1) );
	fft(f, n, 1);				// f[] used to be coefficients, now they're point-values
	fft(g, n, 1);				// g[] used to be coefficients, now they're point-values
	for(int i = 0; i < n; i++)	f[i] = f[i] * g[i];
	fft(f, n, -1);				// f[] used to be point-values, now they're coefficients
	for(int i = 0; i <= lenf + leng; i++)
		printf("%d ", (int)(f[i].real+0.5));
	return 0;
}
```



## 多项式乘法

**Idea**：利用 FFT 进行多项式乘法。

**Complexity**：$O(n\lg n)$ 

**Code**：

```cpp
fft(f, n, 1);				// f[] used to be coefficients, now they're point-values
fft(g, n, 1);				// g[] used to be coefficients, now they're point-values
for(int i = 0; i < n; i++)	f[i] = f[i] * g[i];
fft(f, n, -1);				// f[] used to be point-values, now they're coefficients
```

